#!/usr/bin/env python3
\"\"\"\nRaspberry Pi Client for AI Model Validation Platform\n\nThis script runs on the Raspberry Pi connected to the Camera Under Test (CUT).\nIt monitors GPIO pins or network packets for detection signals and forwards\nthem to the validation platform API.\n\nUsage:\n    python raspberry-pi-client.py --api-url http://your-server:8000 --session-id your-session-id\n\"\"\"\n\nimport time\nimport json\nimport argparse\nimport logging\nimport requests\nfrom datetime import datetime\nfrom typing import Optional\n\ntry:\n    import RPi.GPIO as GPIO\n    HAS_GPIO = True\nexcept ImportError:\n    HAS_GPIO = False\n    print(\"Warning: RPi.GPIO not available. GPIO monitoring disabled.\")\n\nclass VRUDetectionClient:\n    def __init__(self, api_url: str, session_id: str, gpio_pin: int = 18):\n        self.api_url = api_url.rstrip('/')\n        self.session_id = session_id\n        self.gpio_pin = gpio_pin\n        self.running = False\n        \n        # Setup logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(levelname)s - %(message)s'\n        )\n        self.logger = logging.getLogger(__name__)\n        \n        # Setup GPIO if available\n        if HAS_GPIO:\n            self.setup_gpio()\n        \n        self.logger.info(f\"VRU Detection Client initialized\")\n        self.logger.info(f\"API URL: {self.api_url}\")\n        self.logger.info(f\"Session ID: {self.session_id}\")\n        self.logger.info(f\"GPIO Pin: {self.gpio_pin} (available: {HAS_GPIO})\")\n    \n    def setup_gpio(self):\n        \"\"\"Setup GPIO pin for detection signal monitoring\"\"\"\n        try:\n            GPIO.setmode(GPIO.BCM)\n            GPIO.setup(self.gpio_pin, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)\n            GPIO.add_event_detect(\n                self.gpio_pin,\n                GPIO.RISING,\n                callback=self.gpio_callback,\n                bouncetime=200  # Debounce time in ms\n            )\n            self.logger.info(f\"GPIO pin {self.gpio_pin} configured for detection signals\")\n        except Exception as e:\n            self.logger.error(f\"Failed to setup GPIO: {e}\")\n            raise\n    \n    def gpio_callback(self, channel):\n        \"\"\"Callback function for GPIO detection signal\"\"\"\n        timestamp = time.time()\n        self.logger.info(f\"Detection signal received on GPIO pin {channel} at {timestamp}\")\n        self.send_detection_event(timestamp)\n    \n    def send_detection_event(self, timestamp: float, confidence: Optional[float] = None, \n                           class_label: Optional[str] = None):\n        \"\"\"Send detection event to the validation platform API\"\"\"\n        try:\n            payload = {\n                \"test_session_id\": self.session_id,\n                \"timestamp\": timestamp,\n                \"confidence\": confidence,\n                \"class_label\": class_label\n            }\n            \n            response = requests.post(\n                f\"{self.api_url}/api/detection-events\",\n                json=payload,\n                timeout=5\n            )\n            \n            if response.status_code == 200:\n                result = response.json()\n                validation_result = result.get('validation_result', 'Unknown')\n                self.logger.info(\n                    f\"Detection event sent successfully. \"\n                    f\"Validation result: {validation_result}\"\n                )\n            else:\n                self.logger.error(\n                    f\"Failed to send detection event. \"\n                    f\"Status: {response.status_code}, Response: {response.text}\"\n                )\n                \n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"Network error sending detection event: {e}\")\n        except Exception as e:\n            self.logger.error(f\"Error sending detection event: {e}\")\n    \n    def monitor_network_packets(self):\n        \"\"\"Monitor network packets for detection signals (placeholder)\"\"\"\n        # This would implement packet monitoring logic\n        # For example, listening for UDP packets on a specific port\n        self.logger.info(\"Network packet monitoring not implemented yet\")\n        pass\n    \n    def simulate_detections(self, interval: float = 5.0):\n        \"\"\"Simulate detection events for testing purposes\"\"\"\n        self.logger.info(f\"Starting detection simulation (interval: {interval}s)\")\n        \n        import random\n        classes = ['pedestrian', 'cyclist', 'motorcycle']\n        \n        while self.running:\n            try:\n                timestamp = time.time()\n                confidence = random.uniform(0.5, 0.95)\n                class_label = random.choice(classes)\n                \n                self.logger.info(\n                    f\"Simulating detection: {class_label} \"\n                    f\"(confidence: {confidence:.2f}) at {timestamp}\"\n                )\n                \n                self.send_detection_event(timestamp, confidence, class_label)\n                time.sleep(interval)\n                \n            except KeyboardInterrupt:\n                self.logger.info(\"Simulation interrupted by user\")\n                break\n            except Exception as e:\n                self.logger.error(f\"Error in simulation: {e}\")\n                time.sleep(1)\n    \n    def start_monitoring(self, mode: str = 'gpio'):\n        \"\"\"Start monitoring for detection signals\"\"\"\n        self.running = True\n        \n        try:\n            if mode == 'gpio' and HAS_GPIO:\n                self.logger.info(\"Starting GPIO monitoring...\")\n                self.logger.info(\"Press Ctrl+C to stop\")\n                \n                # Keep the main thread alive\n                while self.running:\n                    time.sleep(0.1)\n                    \n            elif mode == 'network':\n                self.logger.info(\"Starting network packet monitoring...\")\n                self.monitor_network_packets()\n                \n            elif mode == 'simulate':\n                self.simulate_detections()\n                \n            else:\n                self.logger.error(f\"Unknown monitoring mode: {mode}\")\n                \n        except KeyboardInterrupt:\n            self.logger.info(\"Monitoring stopped by user\")\n        finally:\n            self.stop_monitoring()\n    \n    def stop_monitoring(self):\n        \"\"\"Stop monitoring and cleanup resources\"\"\"\n        self.running = False\n        \n        if HAS_GPIO:\n            GPIO.cleanup()\n            \n        self.logger.info(\"Monitoring stopped and resources cleaned up\")\n    \n    def test_connection(self) -> bool:\n        \"\"\"Test connection to the validation platform API\"\"\"\n        try:\n            response = requests.get(f\"{self.api_url}/health\", timeout=5)\n            if response.status_code == 200:\n                self.logger.info(\"✅ API connection test successful\")\n                return True\n            else:\n                self.logger.error(f\"❌ API connection test failed: {response.status_code}\")\n                return False\n        except Exception as e:\n            self.logger.error(f\"❌ API connection test failed: {e}\")\n            return False\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Raspberry Pi Client for AI Model Validation Platform\"\n    )\n    parser.add_argument(\n        '--api-url',\n        required=True,\n        help='URL of the validation platform API (e.g., http://192.168.1.100:8000)'\n    )\n    parser.add_argument(\n        '--session-id',\n        required=True,\n        help='Test session ID from the validation platform'\n    )\n    parser.add_argument(\n        '--gpio-pin',\n        type=int,\n        default=18,\n        help='GPIO pin number for detection signals (default: 18)'\n    )\n    parser.add_argument(\n        '--mode',\n        choices=['gpio', 'network', 'simulate'],\n        default='gpio',\n        help='Monitoring mode (default: gpio)'\n    )\n    parser.add_argument(\n        '--test-connection',\n        action='store_true',\n        help='Test API connection and exit'\n    )\n    \n    args = parser.parse_args()\n    \n    # Create client instance\n    client = VRUDetectionClient(\n        api_url=args.api_url,\n        session_id=args.session_id,\n        gpio_pin=args.gpio_pin\n    )\n    \n    # Test connection if requested\n    if args.test_connection:\n        client.test_connection()\n        return\n    \n    # Start monitoring\n    try:\n        client.start_monitoring(args.mode)\n    except Exception as e:\n        logging.error(f\"Fatal error: {e}\")\n        return 1\n    \n    return 0\n\nif __name__ == \"__main__\":\n    exit(main())